From 4843173fe19d32942a6badf3ba08265ac6ff15a1 Mon Sep 17 00:00:00 2001
From: Sharaf Zaman <shzam@sdf.org>
Date: Fri, 26 Nov 2021 15:56:43 +0000
Subject: Android: Rework Storage Access Framework

With this commit we introduce creation of directories, files, and files
inside directories. We also changed the permission model of accessing
the files.
---
 mkspecs/features/java.prf                     |   2 +-
 src/android/jar/AndroidManifest.xml           |   1 -
 src/android/jar/jar.pro                       |   3 +
 .../qt5/android/CachedDocumentFile.java       | 225 +++++
 .../org/qtproject/qt5/android/QtNative.java   | 253 +-----
 .../org/qtproject/qt5/android/SAFFile.java    |  23 +
 .../qtproject/qt5/android/SAFFileManager.java | 800 ++++++++++++++++++
 .../org/qtproject/qt5/android/SAFUtils.java   |  23 +
 .../android/androidcontentfileengine.cpp      | 268 ++++--
 .../android/androidcontentfileengine.h        |  39 +-
 .../qandroidplatformfiledialoghelper.cpp      |   6 +
 .../android/qandroidplatformservices.cpp      |  11 +-
 12 files changed, 1354 insertions(+), 300 deletions(-)
 create mode 100644 src/android/jar/src/org/qtproject/qt5/android/CachedDocumentFile.java
 create mode 100644 src/android/jar/src/org/qtproject/qt5/android/SAFFile.java
 create mode 100644 src/android/jar/src/org/qtproject/qt5/android/SAFFileManager.java
 create mode 100644 src/android/jar/src/org/qtproject/qt5/android/SAFUtils.java

diff --git a/mkspecs/features/java.prf b/mkspecs/features/java.prf
index f1f5e4c10c..1d52f05e52 100644
--- a/mkspecs/features/java.prf
+++ b/mkspecs/features/java.prf
@@ -20,7 +20,7 @@ CONFIG += plugin no_plugin_name_prefix
 javac.input = JAVASOURCES
 javac.output = $$CLASS_DIR
 javac.CONFIG += combine
-javac.commands = javac -source 6 -target 6 -Xlint:unchecked -bootclasspath $$ANDROID_JAR_FILE -cp $$shell_quote($$system_path($$join(JAVACLASSPATH, $$DIRLIST_SEPARATOR))) -d $$shell_quote($$CLASS_DIR) ${QMAKE_FILE_IN}
+javac.commands = javac -source 7 -target 7 -Xlint:unchecked -bootclasspath $$ANDROID_JAR_FILE -cp $$shell_quote($$system_path($$join(JAVACLASSPATH, $$DIRLIST_SEPARATOR))) -d $$shell_quote($$CLASS_DIR) ${QMAKE_FILE_IN}
 # Force rebuild every time, because we don't know the paths of the destination files
 # as they depend on the code.
 javac.depends = FORCE
diff --git a/src/android/jar/AndroidManifest.xml b/src/android/jar/AndroidManifest.xml
index cef88f7f19..ebc6fcfea7 100644
--- a/src/android/jar/AndroidManifest.xml
+++ b/src/android/jar/AndroidManifest.xml
@@ -1,5 +1,4 @@
 <?xml version='1.0' encoding='utf-8'?>
 <manifest xmlns:android="http://schemas.android.com/apk/res/android" android:versionCode="1" android:versionName="1.0" package="org.qtproject.qt5.android">
     <supports-screens android:largeScreens="true" android:normalScreens="true" android:anyDensity="true" android:smallScreens="true"/>
-    <uses-sdk android:minSdkVersion="9" />
 </manifest>
diff --git a/src/android/jar/jar.pro b/src/android/jar/jar.pro
index bda15a0a00..6a610c511d 100644
--- a/src/android/jar/jar.pro
+++ b/src/android/jar/jar.pro
@@ -16,6 +16,9 @@ JAVASOURCES += \
     $$PATHPREFIX/QtLayout.java \
     $$PATHPREFIX/QtMessageDialogHelper.java \
     $$PATHPREFIX/QtNative.java \
+    $$PATHPREFIX/SAFFileManager.java \
+    $$PATHPREFIX/SAFFile.java \
+    $$PATHPREFIX/CachedDocumentFile.java \
     $$PATHPREFIX/QtNativeLibrariesDir.java \
     $$PATHPREFIX/QtSurface.java \
     $$PATHPREFIX/ExtractStyle.java \
diff --git a/src/android/jar/src/org/qtproject/qt5/android/CachedDocumentFile.java b/src/android/jar/src/org/qtproject/qt5/android/CachedDocumentFile.java
new file mode 100644
index 0000000000..15dc727125
--- /dev/null
+++ b/src/android/jar/src/org/qtproject/qt5/android/CachedDocumentFile.java
@@ -0,0 +1,225 @@
+package org.qtproject.qt5.android;
+
+import android.content.ContentResolver;
+import android.content.Context;
+import android.database.Cursor;
+import android.net.Uri;
+import android.os.Build;
+import android.provider.DocumentsContract;
+import android.text.TextUtils;
+import android.util.Log;
+
+public class CachedDocumentFile {
+
+    private static final String TAG = "CachedDocumentFile";
+    private String name;
+    private final String mimeType;
+    private final String documentId;
+    // TODO(sh_zam): do something
+    private Integer size;
+    private Uri uri;
+    private final Context ctx;
+    private Boolean exists = null;
+    private Boolean writable = null;
+
+    public CachedDocumentFile(Context context, String name, String documentId, String mimeType, Integer size, Uri uri) {
+        this.name = name;
+        this.documentId = documentId;
+        this.mimeType = mimeType;
+        this.size = size;
+        this.uri = uri;
+        this.ctx = context;
+    }
+
+    public CachedDocumentFile(Context context, String name, String documentId, String mimeType, Uri uri) {
+        this(context, name, documentId, mimeType, -1, uri);
+    }
+
+    public static CachedDocumentFile fromFileUri(Context context, Uri uri) {
+        final String[] columns = new String[]{
+                DocumentsContract.Document.COLUMN_DISPLAY_NAME,
+                DocumentsContract.Document.COLUMN_DOCUMENT_ID,
+                DocumentsContract.Document.COLUMN_MIME_TYPE,
+                DocumentsContract.Document.COLUMN_SIZE,
+        };
+
+        Cursor cursor = null;
+        try {
+            final ContentResolver resolver = context.getContentResolver();
+            cursor = resolver.query(uri, columns, null, null, null);
+
+            if (cursor.moveToFirst()) {
+                return new CachedDocumentFile(context,
+                        SAFUtils.getColumnValStringOrNull(cursor, DocumentsContract.Document.COLUMN_DISPLAY_NAME),
+                        SAFUtils.getColumnValStringOrNull(cursor, DocumentsContract.Document.COLUMN_DOCUMENT_ID),
+                        SAFUtils.getColumnValStringOrNull(cursor, DocumentsContract.Document.COLUMN_MIME_TYPE),
+                        SAFUtils.getColumnValIntegerOrDefault(cursor, DocumentsContract.Document.COLUMN_SIZE, -1),
+                        uri);
+            }
+        } catch (Exception e) {
+            Log.e(TAG, "fromFileUri(): " + e);
+        } finally {
+            if (cursor != null)
+                cursor.close();
+        }
+        return null;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public String getMimeType() {
+        return mimeType;
+    }
+
+    public String getDocumentId() {
+        return documentId;
+    }
+
+    /**
+     * @return document uri
+     */
+    public Uri getUri() {
+        return uri;
+    }
+
+    public boolean isFile() {
+        return !isDirectory() && !TextUtils.isEmpty(mimeType);
+    }
+
+    public boolean isDirectory() {
+        return DocumentsContract.Document.MIME_TYPE_DIR.equals(mimeType);
+    }
+
+    public long getSize() {
+        return queryForLong(DocumentsContract.Document.COLUMN_SIZE, 0);
+    }
+
+    public boolean rename(String displayName) {
+        try {
+            final Uri newUri = DocumentsContract.renameDocument(
+                    ctx.getContentResolver(), uri, displayName);
+            if (newUri == null || newUri == uri) {
+                return false;
+            }
+            this.name = displayName;
+            this.uri = newUri;
+            return true;
+        } catch (Exception e) {
+            // HACK: see https://crbug.com/1246925.
+            if (isArc()) {
+                String oldUriStr = uri.toString();
+                this.uri = Uri.parse(oldUriStr.replaceFirst(this.name + "$", displayName));
+                this.exists = null;
+                if (exists()) {
+                    this.name = displayName;
+                    return true;
+                } else {
+                    this.uri = Uri.parse(oldUriStr);
+                    return false;
+                }
+            }
+            Log.e(TAG, "rename(): Rename failed: " + e);
+            return false;
+        }
+    }
+
+    public boolean canWrite() {
+        if (writable != null) {
+            return writable;
+        }
+        writable = false;
+        Cursor cursor = null;
+        try {
+            final ContentResolver resolver = ctx.getContentResolver();
+            final String[] columns = {DocumentsContract.Document.COLUMN_FLAGS,
+                    DocumentsContract.Document.COLUMN_MIME_TYPE};
+            cursor = resolver.query(uri, columns, null, null, null);
+            int flags = 0;
+            String mimeType = null;
+            if (cursor != null) {
+                if (cursor.moveToFirst()) {
+                    flags = SAFUtils.getColumnValIntegerOrDefault(cursor,
+                            DocumentsContract.Document.COLUMN_FLAGS, 0);
+                    mimeType = SAFUtils.getColumnValStringOrNull(cursor,
+                            DocumentsContract.Document.COLUMN_MIME_TYPE);
+                }
+            }
+
+            if (DocumentsContract.Document.MIME_TYPE_DIR.equals(mimeType) &&
+                    (flags & DocumentsContract.Document.FLAG_DIR_SUPPORTS_CREATE) != 0) {
+                writable = true;
+            } else if ((flags & DocumentsContract.Document.FLAG_SUPPORTS_WRITE) != 0) {
+                writable = true;
+            }
+
+        } catch (Exception e) {
+            Log.e(TAG, "canWrite(): Failed query: " + e);
+            writable = false;
+        } finally {
+            if (cursor != null) {
+                cursor.close();
+            }
+        }
+        return writable;
+    }
+
+    public boolean exists() {
+        if (exists != null) {
+            return exists;
+        }
+
+        Cursor cursor = null;
+        try {
+            final ContentResolver resolver = ctx.getContentResolver();
+            final String[] columns = {DocumentsContract.Document.COLUMN_DOCUMENT_ID};
+            cursor = resolver.query(uri, columns, null, null, null);
+            exists = cursor.getCount() > 0;
+        } catch (Exception e) {
+            Log.e(TAG, "exists(): Failed query: " + e);
+            exists = false;
+        } finally {
+            if (cursor != null) {
+                cursor.close();
+            }
+        }
+
+        return exists;
+    }
+
+    private long queryForLong(String column, long defaultValue) {
+        Cursor cursor = null;
+        try {
+            final ContentResolver resolver = ctx.getContentResolver();
+            final String[] columns = {column};
+            cursor = resolver.query(uri, columns, null, null, null);
+            if (cursor.moveToFirst() && !cursor.isNull(0)) {
+                return cursor.getLong(0);
+            } else {
+                return defaultValue;
+            }
+        } catch (Exception e) {
+            Log.e(TAG, "queryForLong(): Failed query: " + e);
+            return defaultValue;
+        } finally {
+            if (cursor != null) {
+                cursor.close();
+            }
+        }
+    }
+
+    @Override
+    public boolean equals(Object other) {
+        if (other instanceof CachedDocumentFile) {
+            return ((CachedDocumentFile) other).getUri().equals(this.getUri());
+        }
+        return false;
+    }
+
+    // we need some workarounds on ChromeOS
+    public static boolean isArc() {
+        return (Build.DEVICE != null) && Build.DEVICE.matches(".+_cheets|cheets_.+");
+    }
+}
+
diff --git a/src/android/jar/src/org/qtproject/qt5/android/QtNative.java b/src/android/jar/src/org/qtproject/qt5/android/QtNative.java
index 2981523ab1..7e68206e1a 100644
--- a/src/android/jar/src/org/qtproject/qt5/android/QtNative.java
+++ b/src/android/jar/src/org/qtproject/qt5/android/QtNative.java
@@ -40,22 +40,15 @@
 
 package org.qtproject.qt5.android;
 
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.concurrent.Semaphore;
-import java.io.IOException;
-
 import android.app.Activity;
 import android.app.Service;
-import android.content.ActivityNotFoundException;
-import android.content.Context;
+import android.content.ClipData;
+import android.content.ClipboardManager;
 import android.content.ContentResolver;
+import android.content.Context;
 import android.content.Intent;
-import android.content.pm.PackageManager;
 import android.content.pm.ActivityInfo;
-import android.content.UriPermission;
+import android.content.pm.PackageManager;
 import android.net.Uri;
 import android.os.Build;
 import android.os.Handler;
@@ -65,26 +58,27 @@ import android.content.ClipboardManager;
 import android.content.ClipboardManager.OnPrimaryClipChangedListener;
 import android.content.ClipData;
 import android.content.ClipDescription;
-import android.os.ParcelFileDescriptor;
 import android.util.Log;
 import android.view.ContextMenu;
+import android.view.InputDevice;
 import android.view.KeyEvent;
 import android.view.Menu;
 import android.view.MotionEvent;
 import android.view.View;
-import android.view.InputDevice;
-import android.database.Cursor;
-import android.provider.OpenableColumns;
 
+import java.io.File;
 import java.lang.reflect.Method;
 import java.security.KeyStore;
 import java.security.cert.X509Certificate;
+import java.util.ArrayList;
 import java.util.Iterator;
-import java.util.List;
-import javax.net.ssl.TrustManagerFactory;
+import java.util.concurrent.Semaphore;
+
 import javax.net.ssl.TrustManager;
+import javax.net.ssl.TrustManagerFactory;
 import javax.net.ssl.X509TrustManager;
 
+@SuppressWarnings("unused")
 public class QtNative
 {
     private static Activity m_activity = null;
@@ -114,9 +108,6 @@ public class QtNative
     public static QtThread m_qtThread = new QtThread();
     private static Method m_addItemMethod = null;
 
-    private static HashMap<Integer, ParcelFileDescriptor> m_parcelFileDescriptors = new HashMap<Integer, ParcelFileDescriptor>();
-    private static HashMap<Uri, Integer> m_uriPermissions = new HashMap<Uri, Integer>(); // for URIs which were not accessed through SAF e.g through an Intent
-
 
     private static final Runnable runPendingCppRunnablesRunnable = new Runnable() {
         @Override
@@ -170,228 +161,6 @@ public class QtNative
         return joinedString.split(",");
     }
 
-    public static void addToKnownUri(Uri uri, int modeFlags) {
-        m_uriPermissions.put(uri, modeFlags);
-    }
-
-    public static boolean checkKnownUriPermission(Uri uri, String openMode) {
-        if (!m_uriPermissions.containsKey(uri)) {
-            return false;
-        }
-
-        int modeFlags = 0;
-        if (openMode.startsWith("r")) {
-            modeFlags = Intent.FLAG_GRANT_READ_URI_PERMISSION;
-        }
-
-        if (!"r".equals(openMode)) {
-            modeFlags |= Intent.FLAG_GRANT_WRITE_URI_PERMISSION;
-        }
-
-        return (m_uriPermissions.get(uri) & modeFlags) == modeFlags;
-    }
-
-    private static Uri getUriWithValidPermission(Context context, String uri, String openMode)
-    {
-        try {
-            List<UriPermission> permissions = context.getContentResolver().getPersistedUriPermissions();
-            String uriStr = Uri.parse(uri).getPath();
-
-            for (int i = 0; i < permissions.size(); ++i) {
-                Uri iterUri = permissions.get(i).getUri();
-                boolean isRightPermission = permissions.get(i).isReadPermission();
-
-                if (!openMode.equals("r"))
-                   isRightPermission = permissions.get(i).isWritePermission();
-
-                if (iterUri.getPath().equals(uriStr) && isRightPermission) {
-                    return iterUri;
-                }
-            }
-
-            Uri uriParsed = Uri.parse(uri);
-
-            // give known URIs a try, perhaps we got it in a way we couldn't persist the permissions (say Intent)
-            if (checkKnownUriPermission(uriParsed, openMode)) {
-                return uriParsed;
-            }
-
-            return null;
-        } catch (SecurityException e) {
-            e.printStackTrace();
-            return null;
-        }
-    }
-
-    public static boolean openURL(Context context, String url, String mime)
-    {
-        Uri uri;
-        if (url.startsWith("content:")) {
-            uri = getUriWithValidPermission(context, url, "r");
-            if (uri == null) {
-                Log.e(QtTAG, "openURL(): No permissions to open Uri");
-                return false;
-            }
-        } else {
-            uri = Uri.parse(url);
-        }
-
-        try {
-            Intent intent = new Intent(Intent.ACTION_VIEW, uri);
-            intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
-            if (!mime.isEmpty())
-                intent.setDataAndType(uri, mime);
-
-            activity().startActivity(intent);
-
-            return true;
-        } catch (IllegalArgumentException e) {
-            Log.e(QtTAG, "openURL(): Invalid Uri");
-            return false;
-        } catch (UnsupportedOperationException e) {
-            Log.e(QtTAG, "openURL(): Unsupported operation for given Uri");
-            return false;
-        } catch (ActivityNotFoundException e) {
-            e.printStackTrace();
-            return false;
-        }
-    }
-
-    public static int openFdForContentUrl(Context context, String contentUrl, String openMode)
-    {
-        Uri uri = getUriWithValidPermission(context, contentUrl, openMode);
-        int error = -1;
-
-        if (uri == null) {
-            Log.e(QtTAG, "openFdForContentUrl(): No permissions to open Uri");
-            return error;
-        }
-
-        try {
-            ContentResolver resolver = context.getContentResolver();
-            ParcelFileDescriptor fdDesc = resolver.openFileDescriptor(uri, openMode);
-            m_parcelFileDescriptors.put(fdDesc.getFd(), fdDesc);
-            return fdDesc.getFd();
-        } catch (FileNotFoundException e) {
-            e.printStackTrace();
-            return error;
-        } catch (IllegalArgumentException e) {
-            Log.e(QtTAG, "openFdForContentUrl(): Invalid Uri: " + e);
-            return error;
-        }
-    }
-
-    public static boolean closeFd(int fd)
-    {
-        ParcelFileDescriptor pfd = m_parcelFileDescriptors.get(fd);
-        if (pfd == null) {
-            Log.wtf(QtTAG, "File descriptor doesn't exist in cache");
-            return false;
-        }
-
-        try {
-            pfd.close();
-            return true;
-        } catch (IOException e) {
-            Log.e(QtTAG, "closeFd(): Failed to close the FD", e);
-            return false;
-        }
-    }
-
-    public static long getSize(Context context, String contentUrl)
-    {
-        Uri uri = getUriWithValidPermission(context, contentUrl, "r");
-        long size = -1;
-
-        if (uri == null) {
-            Log.e(QtTAG, "getSize(): No permissions to open Uri");
-            return size;
-        }
-
-        try {
-            ContentResolver resolver = context.getContentResolver();
-            Cursor cur = resolver.query(uri, null, null, null, null);
-
-            if (cur != null) {
-                if (cur.moveToFirst())
-                    size = cur.getLong(cur.getColumnIndex(OpenableColumns.SIZE)); // size column
-                cur.close();
-            }
-            return size;
-        } catch (IllegalArgumentException e) {
-            Log.e(QtTAG, "getSize(): Invalid Uri");
-            return size;
-        }  catch (UnsupportedOperationException e) {
-            Log.e(QtTAG, "getSize(): Unsupported operation for given Uri");
-            return size;
-        }
-    }
-
-    public static boolean checkFileExists(Context context, String contentUrl)
-    {
-        Uri uri = getUriWithValidPermission(context, contentUrl, "r");
-        boolean exists = false;
-
-        if (uri == null) {
-            Log.e(QtTAG, "checkFileExists(): No permissions to open Uri");
-            return exists;
-        }
-
-        try {
-            ContentResolver resolver = context.getContentResolver();
-            Cursor cur = resolver.query(uri, null, null, null, null);
-            if (cur != null) {
-                exists = true;
-                cur.close();
-            }
-            return exists;
-        } catch (IllegalArgumentException e) {
-            Log.e(QtTAG, "checkFileExists(): Invalid Uri");
-            return exists;
-        } catch (UnsupportedOperationException e) {
-            Log.e(QtTAG, "checkFileExists(): Unsupported operation for given Uri");
-            return false;
-        }
-    }
-
-    public static boolean canWriteToUri(Context context, String contentUrl)
-    {
-        Uri uri = getUriWithValidPermission(context, contentUrl, "w");
-
-        if (uri == null) {
-            Log.e(QtTAG, "canWriteToUri(): No permissions to open Uri in \"w\" mode");
-            return false;
-        } else {
-            return true;
-        }
-    }
-
-    public static String getFileNameFromUri(Context context, String contentUrl)
-    {
-        Uri uri = getUriWithValidPermission(context, contentUrl, "r");
-        if (uri == null) {
-            Log.e(QtTAG, "getFileNameFromUri(): No permissions to open Uri:" + contentUrl);
-            return null;
-        }
-
-        String filename = null;
-        try {
-            Cursor cursor = context.getContentResolver().query(uri, null, null, null, null);
-            if (cursor != null) {
-                if (cursor.moveToFirst()) {
-                    filename = cursor.getString(cursor.getColumnIndexOrThrow(OpenableColumns.DISPLAY_NAME));
-                }
-                cursor.close();
-            }
-        } catch (IllegalArgumentException e) {
-            Log.e(QtTAG, "getFileNameFromUri(): Couldn't get filename: " + e.getMessage());
-        } catch (UnsupportedOperationException e) {
-            Log.e(QtTAG, "getFileNameFromUri(): UnsupportedOperation on the Uri: " + e.getMessage());
-        }
-
-        return filename;
-    }
-
     // this method loads full path libs
     public static void loadQtLibraries(final ArrayList<String> libraries)
     {
diff --git a/src/android/jar/src/org/qtproject/qt5/android/SAFFile.java b/src/android/jar/src/org/qtproject/qt5/android/SAFFile.java
new file mode 100644
index 0000000000..fd371bebc2
--- /dev/null
+++ b/src/android/jar/src/org/qtproject/qt5/android/SAFFile.java
@@ -0,0 +1,23 @@
+package org.qtproject.qt5.android;
+
+import android.net.Uri;
+
+import java.util.List;
+
+public class SAFFile {
+    private Uri baseUri;
+    private List<String> segments;
+
+    SAFFile(Uri baseUri, List<String> segments) {
+        this.baseUri = baseUri;
+        this.segments = segments;
+    }
+
+    List<String> getSegments() {
+        return segments;
+    }
+
+    public Uri getBaseUri() {
+        return baseUri;
+    }
+}
diff --git a/src/android/jar/src/org/qtproject/qt5/android/SAFFileManager.java b/src/android/jar/src/org/qtproject/qt5/android/SAFFileManager.java
new file mode 100644
index 0000000000..5191bfb0d4
--- /dev/null
+++ b/src/android/jar/src/org/qtproject/qt5/android/SAFFileManager.java
@@ -0,0 +1,800 @@
+package org.qtproject.qt5.android;
+
+import android.annotation.SuppressLint;
+import android.content.ActivityNotFoundException;
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.UriPermission;
+import android.content.pm.PackageManager;
+import android.database.Cursor;
+import android.net.Uri;
+import android.os.Build;
+import android.os.ParcelFileDescriptor;
+import android.provider.DocumentsContract;
+import android.util.Log;
+import android.webkit.MimeTypeMap;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+
+@SuppressWarnings("unused")
+class FileError {
+    public static final String TAG = "SAFFileManager.FileError";
+    public static final int NO_ERROR = 0;
+    public static final int READ_ERROR = 1;
+    public static final int WRITE_ERROR = 2;
+    public static final int FATAL_ERROR = 3;
+    public static final int RESOURCE_ERROR = 4;
+    public static final int OPEN_ERROR = 5;
+    public static final int ABORT_ERROR = 6;
+    public static final int TIME_OUT_ERROR = 7;
+    public static final int UNSPECIFIED_ERROR = 8;
+    public static final int REMOVE_ERROR = 9;
+    public static final int RENAME_ERROR = 10;
+    public static final int POSITION_ERROR = 11;
+    public static final int RESIZE_ERROR = 12;
+    public static final int PERMISSIONS_ERROR = 13;
+    public static final int COPY_ERROR = 14;
+
+    private String errorString;
+    private int error;
+
+    public String getErrorString() {
+        return errorString;
+    }
+
+    public void setErrorString(String errorString) {
+        this.errorString = errorString;
+        if (error != FileError.NO_ERROR) {
+            Log.w(TAG, errorString);
+        }
+    }
+
+    public int getError() {
+        return error;
+    }
+
+    public void setError(int error) {
+        this.error = error;
+    }
+
+    public void setUnknownError() {
+        setError(FileError.UNSPECIFIED_ERROR);
+        setErrorString("Unknown Error");
+    }
+
+    public void unsetError() {
+        setError(NO_ERROR);
+        setErrorString("No error");
+    }
+}
+
+// Native usage
+@SuppressWarnings("UnusedDeclaration")
+public class SAFFileManager {
+
+    private static final String TAG = "SAFFileManager";
+    private static final String PATH_TREE = "tree";
+
+    @SuppressLint("StaticFieldLeak") // TODO(sh_zam): we only have one activity!
+    private static SAFFileManager sSafFileManager;
+
+    private final Context mCtx;
+    private final HashMap<Uri, CachedDocumentFile> mCachedDocumentFiles = new HashMap<>();
+    private final HashMap<Integer, ParcelFileDescriptor> m_parcelFileDescriptors = new HashMap<>();
+
+    private final FileError mError = new FileError();
+    private List<UriPermission> mCachedPermissions;
+    private final ArrayList<Uri> mCachedListDocumentFiles = new ArrayList<>();
+
+    SAFFileManager(Context ctx) {
+        mCtx = ctx;
+    }
+
+    // Native usage
+    @SuppressWarnings("UnusedDeclaration")
+    public static SAFFileManager instance() {
+        if (sSafFileManager == null) {
+            sSafFileManager = new SAFFileManager(QtNative.getContext());
+        }
+        return sSafFileManager;
+    }
+
+    public static SAFFileManager instance(Context context) {
+        if (sSafFileManager == null) {
+            sSafFileManager = new SAFFileManager(context);
+        }
+        return sSafFileManager;
+    }
+
+    private boolean checkImplicitUriPermission(Uri uri, String openMode) {
+        int modeFlags = 0;
+        if (openMode.startsWith("r")) {
+            modeFlags = Intent.FLAG_GRANT_READ_URI_PERMISSION;
+        }
+
+        if (!"r".equals(openMode)) {
+            modeFlags |= Intent.FLAG_GRANT_WRITE_URI_PERMISSION;
+        }
+
+        return mCtx.checkCallingOrSelfUriPermission(uri, modeFlags) ==
+                PackageManager.PERMISSION_GRANTED;
+    }
+
+    void resetCachedPermission() {
+        mCachedPermissions = mCtx.getContentResolver().getPersistedUriPermissions();
+    }
+
+    /**
+     * The encoding of Path segments is somewhat arbitrary and something which doesn't
+     * seem very safe to rely on. So if we find a matching path we just return
+     * the persisted Uri.<br>
+     * <p>
+     * This function also handles the permission check of implicitly sent Uris.
+     *
+     * @param uri      content Uri, can be Tree Uri or a Single file Uri
+     * @param openMode mode to open the file in
+     * @return The persisted Uri opened through ACTION_OPEN_DOCUMENT,
+     * ACTION_OPEN_DOCUMENT_TREE i.e only if we have permission to the Uri.
+     */
+    Uri getProperlyEncodedUriWithPermissions(Uri uri, String openMode) {
+        if (mCachedPermissions == null) {
+            resetCachedPermission();
+        }
+        final String uriPath = uri.getPath();
+
+        for (int i = 0; i < mCachedPermissions.size(); ++i) {
+            Uri iterUri = mCachedPermissions.get(i).getUri();
+            boolean isRightPermission = mCachedPermissions.get(i).isReadPermission();
+
+            if (!openMode.equals("r"))
+                isRightPermission = mCachedPermissions.get(i).isWritePermission();
+
+            if (iterUri.getPath().equals(uriPath) && isRightPermission) {
+                return iterUri;
+            }
+        }
+
+        // TODO(sh_zam): check encoding
+        // TODO(sh_zam): verify if intent has to exist
+        // check if we received permission from an Intent
+        return (QtNative.activity() != null &&
+                QtNative.activity().getIntent() != null &&
+                checkImplicitUriPermission(uri, openMode)) ? uri : null;
+    }
+
+    /**
+     * Check if we have permission to the Uri. This method also handles tree Uris.
+     * If a Tree Uri is passed in {@code openMode} including write permissions
+     * we create the file under the tree if we have permissions to it.<br>
+     * <p>
+     * Note: The results are undefined for Uris of all types other than:
+     * {@code tree/*} and {@code document/*}.
+     *
+     * @param url      content Uri, can be Tree Uri or a Single file Uri
+     * @param openMode mode to open the file in
+     * @return Uri of the newly created file or passed in url if we have
+     * permission to access the document, otherwise null.
+     */
+    private CachedDocumentFile getDocumentFileWithValidPermissions(String url,
+                                                                   String openMode,
+                                                                   boolean dontCreateDoc) {
+        final Uri uri = Uri.parse(url);
+
+        // it is a file in tree, so we create a new file if "w"
+        if (isTreeUri(uri)) {
+            SAFFile rawSafFile = nearestTreeUri(uri);
+            if (rawSafFile == null) {
+                mError.setError(FileError.PERMISSIONS_ERROR);
+                mError.setErrorString("No permission to access the Document Tree");
+                return null;
+            }
+
+            CachedDocumentFile foundFile = findFileInTree(rawSafFile);
+
+            if (foundFile != null) {
+                return foundFile;
+            }
+
+            // we shouldn't create a file here
+            if ("r".equals(openMode) || dontCreateDoc) {
+                return null;
+            }
+
+            return createFile(rawSafFile, false);
+        } else {
+            Uri resultUri = getProperlyEncodedUriWithPermissions(uri, openMode);
+            if (resultUri != null) {
+                return CachedDocumentFile.fromFileUri(mCtx, resultUri);
+            }
+        }
+
+        mError.setError(FileError.PERMISSIONS_ERROR);
+        mError.setErrorString("No permission to access the Uri");
+        return null;
+    }
+
+    private CachedDocumentFile getDocumentFileWithValidPermissions(String url,
+                                                                   String openMode) {
+        return getDocumentFileWithValidPermissions(url, openMode, false);
+    }
+
+    // Native usage
+    @SuppressWarnings("UnusedDeclaration")
+    private boolean launchUri(String url, String mime) {
+        Uri uri;
+        if (url.startsWith("content:")) {
+            uri = getDocumentFileWithValidPermissions(url, "r").getUri();
+            if (uri == null) {
+                Log.e(TAG, "launchUri(): No permissions to open Uri");
+                return false;
+            }
+        } else {
+            uri = Uri.parse(url);
+        }
+
+        try {
+            Intent intent = new Intent(Intent.ACTION_VIEW, uri);
+            intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
+            if (!mime.isEmpty())
+                intent.setDataAndType(uri, mime);
+
+            QtNative.activity().startActivity(intent);
+
+            return true;
+        } catch (IllegalArgumentException e) {
+            Log.e(TAG, "launchUri(): Invalid Uri");
+            return false;
+        } catch (UnsupportedOperationException e) {
+            Log.e(TAG, "launchUri(): Unsupported operation for given Uri");
+            return false;
+        } catch (ActivityNotFoundException e) {
+            e.printStackTrace();
+            return false;
+        }
+    }
+
+    // Native usage
+    @SuppressWarnings("UnusedDeclaration")
+    synchronized public int openFileDescriptor(String contentUrl, String openMode) {
+        int retry = 0;
+        while (retry < 2) {
+            CachedDocumentFile file =
+                    getDocumentFileWithValidPermissions(contentUrl, openMode);
+
+            if (file == null) {
+                return -1;
+            }
+
+            // take this out
+            try {
+                ContentResolver resolver = mCtx.getContentResolver();
+                ParcelFileDescriptor fdDesc =
+                        resolver.openFileDescriptor(file.getUri(), openMode);
+                m_parcelFileDescriptors.put(fdDesc.getFd(), fdDesc);
+
+                mError.unsetError();
+                return fdDesc.getFd();
+            } catch (Exception e) {
+                Log.w(TAG, "openFileDescriptor(): Failed query: " + e);
+                mCachedDocumentFiles.remove(file.getUri());
+                retry++;
+            }
+        }
+
+        mError.setError(FileError.WRITE_ERROR);
+        mError.setErrorString("Couldn't open file for writing");
+        return -1;
+    }
+
+    // Native usage
+    @SuppressWarnings("UnusedDeclaration")
+    public boolean closeFileDescriptor(int fd) {
+        ParcelFileDescriptor pfd = m_parcelFileDescriptors.get(fd);
+        if (pfd == null) {
+            Log.wtf(TAG, "File descriptor doesn't exist in cache");
+            return false;
+        }
+
+        try {
+            mError.unsetError();
+            pfd.close();
+            return true;
+        } catch (IOException e) {
+            Log.e(TAG, "closeFileDescriptor(): Failed to close the FD", e);
+        }
+        mError.setUnknownError();
+        return false;
+    }
+
+    // Native usage
+    @SuppressWarnings("UnusedDeclaration")
+    public long getSize(String contentUrl) {
+        CachedDocumentFile file =
+                getDocumentFileWithValidPermissions(contentUrl, "r");
+
+        if (file != null) {
+            return file.getSize();
+        } else {
+            mError.setUnknownError();
+            return 0;
+        }
+    }
+
+    // Native usage
+    @SuppressWarnings("UnusedDeclaration")
+    public boolean exists(String contentUrl) {
+        final CachedDocumentFile file =
+                getDocumentFileWithValidPermissions(contentUrl, "r");
+
+        if (file != null && file.exists()) {
+            mError.unsetError();
+            return true;
+        } else {
+            mError.setUnknownError();
+            return false;
+        }
+    }
+
+    // Native usage
+    @SuppressWarnings("UnusedDeclaration")
+    public boolean canWrite(String contentUrl) {
+        final CachedDocumentFile file =
+                getDocumentFileWithValidPermissions(contentUrl, "w", true);
+
+        if (file != null && file.canWrite()) {
+            mError.unsetError();
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    // Native usage
+    @SuppressWarnings("UnusedDeclaration")
+    public String getFileName(String contentUrl) {
+        final CachedDocumentFile file =
+                getDocumentFileWithValidPermissions(contentUrl, "r");
+
+        if (file != null) {
+            mError.unsetError();
+            return file.getName();
+        }
+
+        return null;
+    }
+
+    private String stringJoin(String delimiter, List<String> list) {
+        if (list.size() < 1) {
+            return "";
+        }
+        final StringBuilder builder = new StringBuilder();
+        for (int i = 0; i < list.size(); ++i) {
+            builder.append(list.get(i))
+                    .append(delimiter);
+        }
+
+        // remove trailing
+        builder.delete(builder.length() - delimiter.length(), builder.length());
+        return builder.toString();
+    }
+
+    private Uri uriAppend(Uri uri, List<String> items) {
+        final StringBuilder builder = new StringBuilder(uri.toString());
+        for (String item : items) {
+            builder.append(Uri.encode(File.separator)).append(item);
+        }
+        return Uri.parse(builder.toString());
+    }
+
+    /**
+     * Splits the tree uri:
+     * <p>
+     * {@code "content://com.externalstorage.documents/tree/Primary%3AExample/path1/path2"}
+     * into: <br>
+     * First  = {@code "content://com.externalstorage.documents/tree/Primary%3AExample"},
+     * <br>
+     * Second = {@code "path1/path2"}
+     *
+     * @param treeUri The Tree Uri with a path appended - which may or may not exist
+     * @return a {@link SAFFile} through which we can get the base Uri and path segments
+     * which are to be created or tested
+     */
+    private SAFFile nearestTreeUri(Uri treeUri) {
+        final List<String> paths = treeUri.getPathSegments()
+                .subList(1, treeUri.getPathSegments().size());
+
+        // Test each subtree, going from right to left
+        for (int i = paths.size(); i > 0; --i) {
+            final Uri baseUri =
+                    new Uri.Builder().scheme(ContentResolver.SCHEME_CONTENT)
+                            .authority(treeUri.getAuthority()).appendPath(PATH_TREE)
+                            .appendPath(paths.get(0)).build();
+
+            // we can't use appendPath, because of the weird encoding rules that SAF follows
+            final Uri testUri = getProperlyEncodedUriWithPermissions(
+                    uriAppend(baseUri, paths.subList(1, i)), "rw");
+
+            // we check the permission of the subtree
+            if (testUri != null) {
+                if (i < paths.size()) {
+                    return new SAFFile(testUri, paths.subList(i, paths.size()));
+                } else {
+                    return new SAFFile(testUri, new ArrayList<String>());
+                }
+            }
+        }
+
+        Log.d(TAG, "nearestTreeUri(): No permissions to Uri: " + treeUri);
+        return null;
+    }
+
+    // Native usage
+    @SuppressWarnings("UnusedDeclaration")
+    synchronized public boolean delete(String contentUrl) {
+        final CachedDocumentFile file =
+                getDocumentFileWithValidPermissions(contentUrl, "rw", true);
+        if (file == null) {
+            return false;
+        }
+
+        mCachedDocumentFiles.remove(file.getUri());
+        if (file.isDirectory()) {
+            invalidateCachedDocuments(file.getUri());
+        }
+        return deleteFile(file.getUri());
+    }
+
+    // Native usage
+    public String[] listFileNames(String contentUrl) {
+        final CachedDocumentFile file =
+                getDocumentFileWithValidPermissions(contentUrl, "r");
+
+        if (file == null || !file.isDirectory()) {
+            return null;
+        }
+
+        List<CachedDocumentFile> files = listFiles(file.getUri());
+        String[] result = new String[files.size()];
+        for (int i = 0; i < files.size(); ++i) {
+            CachedDocumentFile docFile = files.get(i);
+            result[i] = docFile.getName();
+            mCachedDocumentFiles.put(docFile.getUri(), docFile);
+            mCachedListDocumentFiles.add(docFile.getUri());
+        }
+
+        return result;
+    }
+
+    // Native usage
+    void resetListCache() {
+        for (Uri uri : mCachedListDocumentFiles) {
+            mCachedDocumentFiles.remove(uri);
+        }
+        mCachedListDocumentFiles.clear();
+    }
+
+    /**
+     * A dumb heuristic method to remove the subdirectories if the parent directory
+     * is removed.
+     *
+     * @param removedUri The document to be deleted
+     */
+    private void invalidateCachedDocuments(Uri removedUri) {
+        String dirname = removedUri.getLastPathSegment();
+        Iterator<Map.Entry<Uri, CachedDocumentFile>> iterator =
+                mCachedDocumentFiles.entrySet().iterator();
+        while (iterator.hasNext()) {
+            Map.Entry<Uri, CachedDocumentFile> entry = iterator.next();
+            if (entry.getKey().getPath().contains(dirname)) {
+                iterator.remove();
+            }
+        }
+    }
+
+    // Native usage
+    @SuppressWarnings("UnusedDeclaration")
+    public boolean isDir(String contentUrl) {
+        final CachedDocumentFile file =
+                getDocumentFileWithValidPermissions(contentUrl, "rw", true);
+        if (file == null) {
+            return false;
+        }
+
+        mError.unsetError();
+        return file.isDirectory();
+    }
+
+    private boolean isTreeUri(Uri uri) {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
+            return DocumentsContract.isTreeUri(uri);
+        } else {
+            final List<String> paths = uri.getPathSegments();
+            return (paths.size() >= 2 && PATH_TREE.equals(paths.get(0)));
+        }
+    }
+
+    // Native usage
+    public boolean isTreeUri(String contentUrl) {
+        return isTreeUri(Uri.parse(contentUrl));
+    }
+
+    synchronized public boolean rename(String contentUrl, String displayName) {
+        final CachedDocumentFile file =
+                getDocumentFileWithValidPermissions(contentUrl, "rw", true);
+        if (file == null) {
+            return false;
+        }
+
+        final Uri oldUri = file.getUri();
+        if (file.rename(displayName)) {
+            mCachedDocumentFiles.remove(oldUri);
+            invalidateCachedDocuments(oldUri);
+            mCachedDocumentFiles.put(file.getUri(), file);
+            resetCachedPermission();
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    // Native usage
+    @SuppressWarnings("UnusedDeclaration")
+    synchronized public boolean mkdir(String contentUrl, boolean createParentDirectories) {
+        if (isDir(contentUrl)) {
+            return true;
+        }
+
+        final Uri uri = Uri.parse(contentUrl);
+        // "tree" and document id make the first two parts of the path
+        if (uri.getPathSegments().size() > 3 && !createParentDirectories) {
+            return false;
+        }
+        final SAFFile rawSafFile = nearestTreeUri(uri);
+        if (rawSafFile == null) {
+            mError.setError(FileError.PERMISSIONS_ERROR);
+            mError.setErrorString("No permission to access the Document Tree");
+            return false;
+        }
+
+        if (createDirectories(rawSafFile) != null) {
+            mError.unsetError();
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    Uri createDirectories(SAFFile file) {
+        final Uri treeUri = file.getBaseUri();
+        List<String> pathSegments = file.getSegments();
+
+        Log.d(TAG, "Creating directory: " + treeUri.toString() +
+                ", segments = " + stringJoin("/", pathSegments));
+
+        Uri parent = DocumentsContract.buildDocumentUriUsingTree(treeUri,
+                DocumentsContract.getTreeDocumentId(treeUri));
+        for (String segment : pathSegments) {
+            final CachedDocumentFile existingFile = findFile(parent, segment);
+
+            if (existingFile != null) {
+                Log.d(TAG, "Exists: " + existingFile.getUri().toString());
+                if (existingFile.isFile()) {
+                    mError.setError(FileError.UNSPECIFIED_ERROR);
+                    mError.setErrorString(
+                            "Couldn't create a directory at the specified path, because a file with same name exists");
+                    return null;
+                }
+
+                parent = existingFile.getUri();
+                continue;
+            }
+
+            final CachedDocumentFile newFile = createDirectory(parent, segment);
+            if (newFile == null) {
+                return null;
+            }
+            parent = newFile.getUri();
+            mCachedDocumentFiles.put(newFile.getUri(), newFile);
+        }
+
+        mError.unsetError();
+        return parent;
+    }
+
+    synchronized private CachedDocumentFile createFile(SAFFile file, boolean force) {
+
+        List<String> pathSegments = file.getSegments();
+
+        Log.d(TAG, "Creating new file: " + file.getBaseUri() + ", filename = "
+                + stringJoin(File.separator, pathSegments));
+
+        final Uri parent = createDirectories(
+                new SAFFile(file.getBaseUri(),
+                        pathSegments.subList(0, pathSegments.size() - 1)));
+        if (parent == null) {
+            return null;
+        }
+
+        final String filename = pathSegments.get(pathSegments.size() - 1);
+        final String mimeType = getMimeTypeFromFilename(filename);
+
+        final CachedDocumentFile foundFile = findFile(parent, filename);
+        if (foundFile != null && foundFile.isFile() && !force) {
+            return foundFile;
+        }
+
+        final CachedDocumentFile newFile = createDocumentImpl(parent, filename, mimeType);
+        if (newFile == null) {
+            return null;
+        }
+        mCachedDocumentFiles.put(newFile.getUri(), newFile);
+        return newFile;
+    }
+
+    private String getMimeTypeFromFilename(String filename) {
+        final int index = filename.lastIndexOf(".");
+        String extension;
+        if (index == -1 || index == filename.length() - 1) {
+            extension = "";
+        } else {
+            extension = filename.substring(index + 1);
+        }
+
+        if (extension.isEmpty()) {
+            return "application/octet-stream";
+        }
+        return MimeTypeMap.getSingleton().getMimeTypeFromExtension(extension);
+    }
+
+
+    private List<CachedDocumentFile> listFiles(Uri documentTreeUri) {
+        Log.d(TAG, "listFiles(): Uri = " + documentTreeUri);
+        final List<CachedDocumentFile> cachedDocumentFiles = new ArrayList<>();
+        // order matters!
+        final String[] columns = new String[]{
+                DocumentsContract.Document.COLUMN_DISPLAY_NAME,
+                DocumentsContract.Document.COLUMN_DOCUMENT_ID,
+                DocumentsContract.Document.COLUMN_MIME_TYPE,
+                DocumentsContract.Document.COLUMN_SIZE
+        };
+
+        Cursor cursor = null;
+        try {
+            final ContentResolver resolver = mCtx.getContentResolver();
+            final Uri childrenTreeUri = DocumentsContract.buildChildDocumentsUriUsingTree(documentTreeUri,
+                    DocumentsContract.getDocumentId(documentTreeUri));
+            cursor = resolver.query(childrenTreeUri, columns, null, null, null);
+            if (cursor == null) {
+                return cachedDocumentFiles;
+            }
+
+            while (cursor.moveToNext()) {
+                final String docId = cursor.getString(1);
+                final Uri fileUri = DocumentsContract.buildDocumentUriUsingTree(documentTreeUri, docId);
+                cachedDocumentFiles.add(new CachedDocumentFile(mCtx,
+                        SAFUtils.getColumnValStringOrNull(cursor, DocumentsContract.Document.COLUMN_DISPLAY_NAME),
+                        SAFUtils.getColumnValStringOrNull(cursor, DocumentsContract.Document.COLUMN_DOCUMENT_ID),
+                        SAFUtils.getColumnValStringOrNull(cursor, DocumentsContract.Document.COLUMN_MIME_TYPE),
+                        SAFUtils.getColumnValIntegerOrDefault(cursor, DocumentsContract.Document.COLUMN_SIZE, -1),
+                        fileUri));
+            }
+        } catch (Exception e) {
+            Log.e(TAG, "Invalid document Uri: " + documentTreeUri);
+            // TODO(sh_zam): a test is needed
+            mCachedDocumentFiles.remove(documentTreeUri);
+            invalidateCachedDocuments(documentTreeUri);
+        } finally {
+            if (cursor != null)
+                cursor.close();
+        }
+
+        return cachedDocumentFiles;
+    }
+
+    /**
+     * Find the file under the tree. This function can take pathSegments which
+     * allow looking recursively in the document's subtree.
+     *
+     * @param safFile {@link SAFFile}
+     * @return {@link CachedDocumentFile} if the document is found, null otherwise.
+     */
+    private CachedDocumentFile findFileInTree(SAFFile safFile) {
+        List<String> pathSegments = safFile.getSegments();
+        Uri parent = DocumentsContract.buildDocumentUriUsingTree(safFile.getBaseUri(),
+                DocumentsContract.getTreeDocumentId(safFile.getBaseUri()));
+
+        CachedDocumentFile documentFile;
+        if (mCachedDocumentFiles.containsKey(parent)) {
+            documentFile = mCachedDocumentFiles.get(parent);
+        } else {
+            documentFile = CachedDocumentFile.fromFileUri(mCtx, parent);
+            mCachedDocumentFiles.put(documentFile.getUri(), documentFile);
+        }
+
+        for (int i = 0; i < pathSegments.size(); ++i) {
+            documentFile = findFile(parent, pathSegments.get(i));
+            if (documentFile == null) {
+                return null;
+            }
+
+            if (documentFile.isFile()) {
+                if (i == pathSegments.size() - 1) {
+                    return documentFile;
+                } else {
+                    return null;
+                }
+            }
+            parent = documentFile.getUri();
+        }
+
+        return documentFile;
+    }
+
+    /**
+     * Find the file under subtree
+     *
+     * @param documentTreeUri a Uri with both "tree" and "document".
+     * @param filename        name of the file or directory.
+     * @return {@link CachedDocumentFile} if the document is found in cache or under
+     * the tree, null otherwise.
+     */
+    private CachedDocumentFile findFile(Uri documentTreeUri, String filename) {
+        {
+            final Uri expectedUri = DocumentsContract.buildDocumentUriUsingTree(documentTreeUri,
+                    DocumentsContract.getDocumentId(documentTreeUri) + "/" + filename);
+            // check in the cached documents first
+            if (mCachedDocumentFiles.containsKey(expectedUri)) {
+                return mCachedDocumentFiles.get(expectedUri);
+            }
+        }
+
+        // check the tree now
+        List<CachedDocumentFile> cachedDocumentFiles = listFiles(documentTreeUri);
+        for (CachedDocumentFile file : cachedDocumentFiles) {
+            if (filename.equals(file.getName())) {
+                mCachedDocumentFiles.put(file.getUri(), file);
+                return file;
+            }
+        }
+
+        return null;
+    }
+
+    private CachedDocumentFile createDocumentImpl(Uri parent, String displayName, String mimeType) {
+        try {
+            final Uri fileUri = DocumentsContract.createDocument(mCtx.getContentResolver(),
+                    parent, mimeType, displayName);
+            return new CachedDocumentFile(mCtx, displayName,
+                    DocumentsContract.getDocumentId(fileUri),
+                    mimeType,
+                    fileUri);
+        } catch (Exception e) {
+            mError.setUnknownError();
+            Log.e(TAG, "Error creating a file: uri = " + parent +
+                    ", displayName = " + displayName + ", mimeType = " + mimeType);
+            return null;
+        }
+    }
+
+    private boolean deleteFile(Uri documentUri) {
+        try {
+            return DocumentsContract.deleteDocument(mCtx.getContentResolver(),
+                    documentUri);
+        } catch (Exception e) {
+            mError.setUnknownError();
+            Log.e(TAG, "Error deleting a file: uri = " + documentUri);
+            return false;
+        }
+    }
+
+    private CachedDocumentFile createDirectory(Uri parent, String displayName) {
+        return createDocumentImpl(parent, displayName, DocumentsContract.Document.MIME_TYPE_DIR);
+    }
+}
diff --git a/src/android/jar/src/org/qtproject/qt5/android/SAFUtils.java b/src/android/jar/src/org/qtproject/qt5/android/SAFUtils.java
new file mode 100644
index 0000000000..51f8f710df
--- /dev/null
+++ b/src/android/jar/src/org/qtproject/qt5/android/SAFUtils.java
@@ -0,0 +1,23 @@
+package org.qtproject.qt5.android;
+
+import android.database.Cursor;
+
+public class SAFUtils {
+
+    public static String getColumnValStringOrNull(Cursor cursor, String column) {
+        int index = cursor.getColumnIndex(column);
+        if (index == -1) {
+            return null;
+        }
+        return cursor.getString(index);
+    }
+
+    public static Integer getColumnValIntegerOrDefault(Cursor cursor, String column, int defaultVal) {
+        int index = cursor.getColumnIndex(column);
+        if (index == -1) {
+            return defaultVal;
+        }
+        return cursor.getInt(index);
+    }
+
+}
diff --git a/src/plugins/platforms/android/androidcontentfileengine.cpp b/src/plugins/platforms/android/androidcontentfileengine.cpp
index ba11a50e85..b9ed95b768 100644
--- a/src/plugins/platforms/android/androidcontentfileengine.cpp
+++ b/src/plugins/platforms/android/androidcontentfileengine.cpp
@@ -45,10 +45,17 @@
 #include <QDebug>
 
 AndroidContentFileEngine::AndroidContentFileEngine(const QString &f)
-    : m_fd(-1), m_file(f), m_resolvedName(QString())
+    : m_fd(-1)
+    , m_file(f)
+    , m_resolvedName(QString())
+    , m_safFileManager(QJNIObjectPrivate::callStaticObjectMethod(
+          "org/qtproject/qt5/android/SAFFileManager", "instance",
+          "()Lorg/qtproject/qt5/android/SAFFileManager;"))
+    , m_safError(m_safFileManager.getObjectField("mError",
+                                                 "Lorg/qtproject/qt5/android/FileError;"))
 {
+    m_resolvedName = getResolvedFileName(f);
     setFileName(f);
-    setResolvedFileName(f);
 }
 
 bool AndroidContentFileEngine::open(QIODevice::OpenMode openMode)
@@ -74,35 +81,60 @@ bool AndroidContentFileEngine::open(QIODevice::OpenMode openMode)
         openModeStr += QLatin1Char('a');
     }
 
-    const auto fd = QJNIObjectPrivate::callStaticMethod<jint>("org/qtproject/qt5/android/QtNative",
-        "openFdForContentUrl",
-        "(Landroid/content/Context;Ljava/lang/String;Ljava/lang/String;)I",
-        QtAndroidPrivate::context(),
+    const auto fd = m_safFileManager.callMethod<jint>(
+        "openFileDescriptor", "(Ljava/lang/String;Ljava/lang/String;)I",
         QJNIObjectPrivate::fromString(m_file).object(),
         QJNIObjectPrivate::fromString(openModeStr).object());
 
     if (fd < 0) {
-        setError(QFileDevice::OpenError, QLatin1String("The file could not be opened."));
+        setErrorFromSAF();
         return false;
     }
 
     setFileDescriptor(fd);
-    return QFSFileEngine::open(openMode, m_fd, QFile::AutoCloseHandle);
+    return QFSFileEngine::open(openMode, m_fd, QFile::DontCloseHandle);
 }
 
 bool AndroidContentFileEngine::close()
 {
-    return QJNIObjectPrivate::callStaticMethod<jboolean>(
-        "org/qtproject/qt5/android/QtNative", "closeFd",
-        "(I)Z", m_fd);
+    setErrorFromSAF();
+    return m_safFileManager.callMethod<jboolean>("closeFileDescriptor", "(I)Z", m_fd);
+}
+
+QJNIObjectPrivate toJavaUri(const QString &stringUri)
+{
+    const auto uri = QJNIObjectPrivate::callStaticObjectMethod(
+        "android/net/Uri", "parse", "(Ljava/lang/String;)Landroid/net/Uri;",
+        QJNIObjectPrivate::fromString(stringUri).object());
+
+    if (!uri.isValid()) {
+        qWarning("Invalid Uri returned");
+    }
+    return uri;
+}
+
+bool AndroidContentFileEngine::mkdir(const QString &dirName, bool createParentDirectories) const
+{
+    return m_safFileManager.callMethod<jboolean>(
+        "mkdir", "(Ljava/lang/String;Z)Z",
+        QJNIObjectPrivate::fromString(dirName).object(), createParentDirectories);
+}
+
+bool AndroidContentFileEngine::rmdir(const QString &dirName, bool recurseParentDirectories) const
+{
+    if (recurseParentDirectories) {
+        qWarning() << "rmpath(): Unsupported";
+    }
+    return m_safFileManager.callMethod<jboolean>(
+        "delete", "(Ljava/lang/String;)Z",
+        QJNIObjectPrivate::fromString(dirName).object());
 }
 
 qint64 AndroidContentFileEngine::size() const
 {
-    const jlong size = QJNIObjectPrivate::callStaticMethod<jlong>(
-            "org/qtproject/qt5/android/QtNative", "getSize",
-            "(Landroid/content/Context;Ljava/lang/String;)J", QtAndroidPrivate::context(),
-            QJNIObjectPrivate::fromString(m_file).object());
+    const jlong size = m_safFileManager.callMethod<jlong>(
+        "getSize", "(Ljava/lang/String;)J",
+        QJNIObjectPrivate::fromString(m_file).object());
     return (qint64)size;
 }
 
@@ -110,44 +142,65 @@ AndroidContentFileEngine::FileFlags AndroidContentFileEngine::fileFlags(FileFlag
 {
     const FileFlags commonFlags(ReadOwnerPerm|ReadUserPerm|ReadGroupPerm|ReadOtherPerm|ExistsFlag);
     FileFlags flags;
-    const bool exists = QJNIObjectPrivate::callStaticMethod<jboolean>(
-            "org/qtproject/qt5/android/QtNative", "checkFileExists",
-            "(Landroid/content/Context;Ljava/lang/String;)Z", QtAndroidPrivate::context(),
-            QJNIObjectPrivate::fromString(m_file).object());
+    const bool exists =
+        m_safFileManager.callMethod<jboolean>("exists", "(Ljava/lang/String;)Z",
+                                          QJNIObjectPrivate::fromString(m_file).object());
     if (!exists)
         return flags;
 
-    flags = FileType | commonFlags;
+    flags = commonFlags;
 
-    const bool canWrite = QJNIObjectPrivate::callStaticMethod<jboolean>(
-            "org/qtproject/qt5/android/QtNative", "canWriteToUri",
-            "(Landroid/content/Context;Ljava/lang/String;)Z", QtAndroidPrivate::context(),
-            QJNIObjectPrivate::fromString(m_file).object());
+    const bool canWrite =
+        m_safFileManager.callMethod<jboolean>("canWrite", "(Ljava/lang/String;)Z",
+                                          QJNIObjectPrivate::fromString(m_file).object());
     if (canWrite) {
         flags |= (WriteOwnerPerm|WriteUserPerm|WriteGroupPerm|WriteOtherPerm);
     }
+
+    const bool isDir = m_safFileManager.callMethod<jboolean>(
+        "isDir", "(Ljava/lang/String;)Z", QJNIObjectPrivate::fromString(m_file).object());
+    if (isDir) {
+        flags = DirectoryType | flags;
+    } else {
+        flags = FileType | flags;
+    }
     return type & flags;
 }
 
 QString AndroidContentFileEngine::fileName(FileName f) const
 {
     switch (f) {
-        case DefaultName: {
+    case DefaultName: {
+        // the file isn't created here, so the resolved filename is empty
+        if (m_resolvedName.isEmpty()) {
+            const int pos = m_file.lastIndexOf(QChar(QLatin1Char('/')));
+            return m_file.mid(pos + 1);
+        } else {
             return m_resolvedName;
         }
-        case PathName:
-        case AbsoluteName:
-        case AbsolutePathName:
-        case CanonicalName:
-        case CanonicalPathName:
-            return m_file;
-
-        case BaseName: {
-            const int pos = m_resolvedName.lastIndexOf(QChar(QLatin1Char('/')));
-            return m_resolvedName.mid(pos);
+    }
+    case PathName:
+    case AbsoluteName:
+    case AbsolutePathName:
+    case CanonicalName:
+        return m_file;
+    case CanonicalPathName: {
+        const bool isTree = m_safFileManager.callMethod<jboolean>(
+            "isTreeUri", "(Ljava/lang/String;)Z",
+            QJNIObjectPrivate::fromString(m_file).object());
+
+        if (isTree) {
+            const int pos = m_file.lastIndexOf(QChar(QLatin1Char('/')));
+            return m_file.left(pos);
         }
-        default:
-            return QString();
+        return m_file;
+    }
+    case BaseName: {
+        const int pos = m_resolvedName.lastIndexOf(QChar(QLatin1Char('/')));
+        return m_resolvedName.mid(pos);
+    }
+    default:
+        return QString();
     }
 }
 
@@ -161,32 +214,87 @@ bool AndroidContentFileEngine::isRelativePath() const
     }
 }
 
-void AndroidContentFileEngine::setResolvedFileName(const QString& uri)
+bool AndroidContentFileEngine::rename(const QString &newName)
+{
+    auto renameSaf = [this](QString newName) -> bool {
+        return m_safFileManager.callMethod<jboolean>(
+            "rename", "(Ljava/lang/String;Ljava/lang/String;)Z",
+            QJNIObjectPrivate::fromString(m_file).object(),
+            QJNIObjectPrivate::fromString(newName).object());
+    };
+
+    // if the file doesn't have scheme it means the newName is only the fileName part
+    if (!newName.startsWith("content://")) {
+        return renameSaf(newName);
+    }
+
+    auto getPos = [](QString file) {
+        int posDecoded = file.lastIndexOf(QLatin1String("/"));
+        int posEncoded = file.lastIndexOf(QLatin1String("%2F"));
+        return posEncoded > posDecoded ? posEncoded : posDecoded;
+    };
+
+    const QString parent = m_file.left(getPos(m_file));
+
+    if (newName.contains(parent)) {
+        const int pos = getPos(newName);
+        const QString displayName = newName.mid(pos + 1);
+
+        return renameSaf(displayName);
+    }
+
+    m_resolvedName = getResolvedFileName(m_file);
+    return false;
+}
+
+bool AndroidContentFileEngine::remove()
 {
-    QJNIObjectPrivate resolvedName = QJNIObjectPrivate::callStaticObjectMethod(
-        "org/qtproject/qt5/android/QtNative",
-        "getFileNameFromUri",
-        "(Landroid/content/Context;Ljava/lang/String;)Ljava/lang/String;",
-        QtAndroidPrivate::context(),
-        QJNIObjectPrivate::fromString(uri).object());
+    return m_safFileManager.callMethod<jboolean>(
+        "delete", "(Ljava/lang/String;)Z",
+        QJNIObjectPrivate::fromString(m_file).object());
+}
+
+QString AndroidContentFileEngine::getResolvedFileName(const QString &path) const
+{
+    QJNIObjectPrivate resolvedName = m_safFileManager.callObjectMethod(
+        "getFileName", "(Ljava/lang/String;)Ljava/lang/String;",
+        QJNIObjectPrivate::fromString(path).object());
 
     if (resolvedName.isValid()) {
-        m_resolvedName = resolvedName.toString();
-    } else {
-        qWarning("setResolvedFileName: Couldn't resolve the URI");
+        return resolvedName.toString();
     }
+    return QString();
+}
+
+QAbstractFileEngine::Iterator *
+AndroidContentFileEngine::beginEntryList(QDir::Filters filters,
+                                         const QStringList &filterNames)
+{
+    return new AndroidContentFileEngineIterator(m_safFileManager, filters, filterNames);
 }
 
-void AndroidContentFileEngine::setFileDescriptor(const int fd)
+QAbstractFileEngine::Iterator *AndroidContentFileEngine::endEntryList()
 {
-    m_fd = fd;
+    return nullptr;
 }
 
+void AndroidContentFileEngine::setFileDescriptor(const int fd) { m_fd = fd; }
+
+void AndroidContentFileEngine::setErrorFromSAF()
+{
+    auto error = m_safError.callMethod<jint>("getError");
+    auto errorString =
+        m_safError.callObjectMethod("getErrorString", "()Ljava/lang/String;");
+    if (errorString.isValid()) {
+        setError(static_cast<QFileDevice::FileError>(error), errorString.toString());
+    }
+}
 
 AndroidContentFileEngineHandler::AndroidContentFileEngineHandler() = default;
 AndroidContentFileEngineHandler::~AndroidContentFileEngineHandler() = default;
 
-QAbstractFileEngine* AndroidContentFileEngineHandler::create(const QString &fileName) const
+QAbstractFileEngine *
+AndroidContentFileEngineHandler::create(const QString &fileName) const
 {
     if (!fileName.startsWith(QLatin1String("content"))) {
         return nullptr;
@@ -194,3 +302,63 @@ QAbstractFileEngine* AndroidContentFileEngineHandler::create(const QString &file
 
     return new AndroidContentFileEngine(fileName);
 }
+
+AndroidContentFileEngineIterator::AndroidContentFileEngineIterator(
+    QJNIObjectPrivate safFileManager, QDir::Filters filters,
+    const QStringList &filterNames)
+    : QAbstractFileEngineIterator(filters, filterNames)
+    , m_safFileManager(safFileManager)
+{
+}
+
+AndroidContentFileEngineIterator::~AndroidContentFileEngineIterator()
+{
+    m_safFileManager.callMethod<void>("resetListCache");
+}
+
+QString AndroidContentFileEngineIterator::next()
+{
+    if (!hasNext()) {
+        return QString();
+    }
+    m_index++;
+
+    // just like it is in QFSFileEngineIterator
+    return currentFilePath();
+}
+
+bool AndroidContentFileEngineIterator::hasNext() const
+{
+    if (m_index == -2) {
+        fetchEntries();
+        m_index++;
+    }
+    return m_index < m_entries.size() && m_entries.size() > 0;
+}
+
+QString AndroidContentFileEngineIterator::currentFileName() const
+{
+    if (!hasNext()) {
+        return QString();
+    }
+    return m_entries.at(m_index);
+}
+
+void AndroidContentFileEngineIterator::fetchEntries() const
+{
+    QJNIObjectPrivate fileNames = m_safFileManager.callObjectMethod(
+        "listFileNames", "(Ljava/lang/String;)[Ljava/lang/String;",
+        QJNIObjectPrivate::fromString(path()).object());
+
+    if (!fileNames.isValid()) {
+        return;
+    }
+
+    QJNIEnvironmentPrivate env;
+    const jsize length = env->GetArrayLength(static_cast<jarray>(fileNames.object()));
+    for (int i = 0; i < length; ++i) {
+        QJNIObjectPrivate elem(
+            env->GetObjectArrayElement(static_cast<jobjectArray>(fileNames.object()), i));
+        m_entries << elem.toString();
+    }
+}
diff --git a/src/plugins/platforms/android/androidcontentfileengine.h b/src/plugins/platforms/android/androidcontentfileengine.h
index 6769352ffd..8c120f8023 100644
--- a/src/plugins/platforms/android/androidcontentfileengine.h
+++ b/src/plugins/platforms/android/androidcontentfileengine.h
@@ -41,6 +41,9 @@
 #define ANDROIDCONTENTFILEENGINE_H
 
 #include <private/qfsfileengine_p.h>
+#include <private/qjni_p.h>
+
+class AndroidContentFileEngineIterator;
 
 class AndroidContentFileEngine : public QFSFileEngine
 {
@@ -48,21 +51,32 @@ public:
     AndroidContentFileEngine(const QString &fileName);
     bool open(QIODevice::OpenMode openMode) override;
     bool close() override;
+    bool mkdir(const QString &dirName, bool createParentDirectories) const override;
+    bool rmdir(const QString &dirName, bool recurseParentDirectories) const override;
     qint64 size() const override;
     FileFlags fileFlags(FileFlags type = FileInfoAll) const override;
     QString fileName(FileName file = DefaultName) const override;
     bool isRelativePath() const override;
+    bool rename(const QString &newName) override;
+    bool remove() override;
+
+    QString getResolvedFileName(const QString &file) const;
 
-    /// Resolves the URI to the actual filename
-    void setResolvedFileName(const QString& uri);
+    QAbstractFileEngine::Iterator *
+    beginEntryList(QDir::Filters filters, const QStringList &filterNames) override;
+    QAbstractFileEngine::Iterator *endEntryList() override;
 
 private:
     void setFileDescriptor(const int fd);
 
+    void setErrorFromSAF();
+
 private:
     int m_fd;
     QString m_file;
     QString m_resolvedName;
+    QJNIObjectPrivate m_safFileManager;
+    QJNIObjectPrivate m_safError;
 };
 
 class AndroidContentFileEngineHandler : public QAbstractFileEngineHandler
@@ -73,4 +87,25 @@ public:
     QAbstractFileEngine *create(const QString &fileName) const override;
 };
 
+class AndroidContentFileEngineIterator : public QAbstractFileEngineIterator {
+public:
+    AndroidContentFileEngineIterator(QJNIObjectPrivate safFileManager,
+                                     QDir::Filters filters,
+                                     const QStringList &filterNames);
+    ~AndroidContentFileEngineIterator();
+
+    QString next() override;
+    bool hasNext() const override;
+    QString currentFileName() const override;
+
+private:
+    void fetchEntries() const;
+
+private:
+
+    mutable QStringList m_entries;
+    mutable int m_index = -2;
+    QJNIObjectPrivate m_safFileManager;
+};
+
 #endif // ANDROIDCONTENTFILEENGINE_H
diff --git a/src/plugins/platforms/android/qandroidplatformfiledialoghelper.cpp b/src/plugins/platforms/android/qandroidplatformfiledialoghelper.cpp
index 00b5b0887c..e7068d369a 100644
--- a/src/plugins/platforms/android/qandroidplatformfiledialoghelper.cpp
+++ b/src/plugins/platforms/android/qandroidplatformfiledialoghelper.cpp
@@ -119,6 +119,12 @@ void QAndroidPlatformFileDialogHelper::takePersistableUriPermission(const QJNIOb
             "getContentResolver", "()Landroid/content/ContentResolver;");
     contentResolver.callMethod<void>("takePersistableUriPermission", "(Landroid/net/Uri;I)V",
                                      uri.object(), modeFlags);
+
+    QJNIObjectPrivate safFileManager = QJNIObjectPrivate::callStaticObjectMethod(
+          "org/qtproject/qt5/android/SAFFileManager", "instance",
+          "()Lorg/qtproject/qt5/android/SAFFileManager;");
+
+    safFileManager.callMethod<void>("resetCachedPermission");
 }
 
 void QAndroidPlatformFileDialogHelper::setIntentTitle(const QString &title)
diff --git a/src/plugins/platforms/android/qandroidplatformservices.cpp b/src/plugins/platforms/android/qandroidplatformservices.cpp
index c095613ce7..5abfc7bbb5 100644
--- a/src/plugins/platforms/android/qandroidplatformservices.cpp
+++ b/src/plugins/platforms/android/qandroidplatformservices.cpp
@@ -68,10 +68,13 @@ bool QAndroidPlatformServices::openUrl(const QUrl &theUrl)
 
     QJNIObjectPrivate urlString = QJNIObjectPrivate::fromString(url.toString());
     QJNIObjectPrivate mimeString = QJNIObjectPrivate::fromString(mime);
-    return QJNIObjectPrivate::callStaticMethod<jboolean>(
-            QtAndroid::applicationClass(), "openURL",
-            "(Landroid/content/Context;Ljava/lang/String;Ljava/lang/String;)Z",
-            QtAndroidPrivate::context(), urlString.object(), mimeString.object());
+    QJNIObjectPrivate safFileManager = QJNIObjectPrivate::callStaticObjectMethod(
+        "org/qtproject/qt5/android/SAFFileManager", "instance",
+        "()Lorg/qtproject/qt5/android/SAFFileManager;");
+
+    return safFileManager.callMethod<jboolean>("launchUri",
+                                               "(Ljava/lang/String;Ljava/lang/String;)Z",
+                                               urlString.object(), mimeString.object());
 }
 
 bool QAndroidPlatformServices::openDocument(const QUrl &url)
-- 
2.34.1

